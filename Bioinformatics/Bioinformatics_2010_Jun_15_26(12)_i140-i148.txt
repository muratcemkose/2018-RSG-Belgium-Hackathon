
==== Front
BioinformaticsbioinformaticsbioinfoBioinformatics1367-48031367-4811Oxford University Press 10.1093/bioinformatics/btq198btq198Ismb 2010 Conference Proceedings July 11 to July 13, 2010, Boston, Ma, UsaOriginal PapersEvolution and Comparative GenomicsClose lower and upper bounds for the minimum reticulate network of multiple phylogenetic trees Wu Yufeng Department of Computer Science and Engineering, University of Connecticut, Storrs, CT 06269, USA15 6 2010 1 6 2010 1 6 2010 26 12 i140 i148 ¬© The Author(s) 2010. Published by Oxford University Press.2010This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/2.5), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.Motivation: Reticulate network is a model for displaying and quantifying the effects of complex reticulate processes on the evolutionary history of species undergoing reticulate evolution. A central computational problem on reticulate networks is: given a set of phylogenetic trees (each for some region of the genomes), reconstruct the most parsimonious reticulate network (called the minimum reticulate network) that combines the topological information contained in the given trees. This problem is well-known to be NP-hard. Thus, existing approaches for this problem either work with only two input trees or make simplifying topological assumptions.

Results: We present novel results on the minimum reticulate network problem. Unlike existing approaches, we address the fully general problem: there is no restriction on the number of trees that are input, and there is no restriction on the form of the allowed reticulate network. We present lower and upper bounds on the minimum number of reticulation events in the minimum reticulate network (and infer an approximately parsimonious reticulate network). A program called PIRN implements these methods, which also outputs a graphical representation of the inferred network. Empirical results on simulated and biological data show that our methods are practical for a wide range of data. More importantly, the lower and upper bounds match for many datasets (especially when the number of trees is small or reticulation level is low), and this allows us to solve the minimum reticulate network problem exactly for these datasets.

Availability: A software tool, PIRN, is available for download from the web page: http://www.engr.uconn.edu/~ywu.

Contact: ywu@engr.uconn.edu

Supplementary information: Supplementary data is available at Bioinformatics online.
==== Body
1 INTRODUCTION
Reticulate evolution, a form of evolution with hybridization and genetic exchanges between two species, are common in many organisms: bacteria, plants, fish, amphibians and many others. For better understanding of reticulate evolution, several reticulate evolutionary models have been proposed and actively studied to address various reticulate processes, such as hybrid speciation, lateral gene transfer and recombination. Since most of these models are in the forms of networks, we call them reticulate networks1. We refer the readers to (Huson, 2007; Huson and Bryant, 2006; Nakhleh, 2009; Semple, 2007) for surveys of different reticulate network models.

The key computational problem related to these models is the inference of reticulate networks. Depending on the types of biological processes involved, data for network inference may be in different forms, such as phylogenetic trees for some short genomic regions (called genes in this article) or aligned DNA sequences. In this article, we focus on inferring reticulate networks from a set of correlated phylogenetic trees. Here is the biological motivation for our problem. Suppose multiple phylogenetic trees (called gene trees in this article) are reconstructed, each from some gene for these species. Due to reticulate evolution, different genomic regions (say genes) may be inherited from different ancestral genomes and their evolutionary histories may not be the same (but are still related). Thus, these trees are correlated but not identical. No single phylogenetic tree can faithfully model the evolution of the species, and a more complex network model (i.e. reticulate network as studied in e.g. Baroni et al., 2004; Huson, 2007; Huson et al., 2005; Nakhleh et al., 2004; Semple, 2007) is needed.

Imagine we are given a set of ‚Äòtrue‚Äô gene trees and a ‚Äòtrue‚Äô reticulate network that models the evolutionary history of these genes. The network can be considered as a compact representation of these gene trees in the sense that one should be able to ‚Äòtrace‚Äô a gene tree within the network. We say such a gene tree is displayed in the network. This motivates a natural problem, which is called ‚Äòthe holy grail of reticulate evolution‚Äô in (Nakhleh, 2009): given a set of gene trees, reconstruct a reticulate network that displays every given gene tree. Such an inferred network reveals important correlation of evolutionary history of multiple genes. Since there exists many such networks, a common formulation is to find the one with the fewest reticulation events. Such a network is called the minimum reticulate network. The central computational problem on reticulate networks, the minimum reticulate network problem, is: given a set of gene trees, reconstruct the minimum reticulate network that displays these gene trees. This formulation may be reasonable when reticulation is believed to be rare.

In general, this problem is computationally challenging: even the case with only two gene trees is known to be NP-complete (Bordewich and Semple, 2004, 2007; Hein et al., 1996). There are several existing approaches for reconstructing the exact minimum reticulate networks when there are only two gene trees (Bordewich et al., 2007; Linz and Semple, 2009; Wu, 2009; Wu and Wang, 2010). Clearly restricting to just two gene trees is a big limitation: more gene trees will be more informative to phylogenetic inference, and DNA sequences of many genes are available. Alternatively, there are also a number of approaches making simplifications to the reticulate network model, e.g. by imposing additional topological constraints on reticulate networks (Gusfield, 2005; Huson and Klopper, 2007; Huson et al., 2009; Nakhleh et al., 2005) or working with small-scale tree topological features (Huson et al., 2005; Huson and Klopper, 2007, van Iersel et al., 2008). Such simplification often leads to significantly faster approaches. However, it is sometimes unclear how biologically meaningful these added topological constraints are. Even in the case where additional simplifications are reasonable, one may still want to compare with the unconstrained minimum reticulate networks.

Contributions: In this article, we present new approaches for the minimum reticulate network problem with three or more gene trees for unconstrained, general, reticulate networks (e.g. without needing to assume that the network has some restricted form, such as being a galled-tree or galled network). Thus our work is more general than some previous approaches (Huson and Klopper, 2007; Huson et al., 2005; Huson et al., 2009). In particular, we develop a lower bound (the RH bound) and an upper bound (the SIT bound) for the minimum reticulate network problem with multiple gene trees. We show the correctness of the bounds. We give a closed-form formula for the RH bound for the case of three gene trees. We also show how to compute these bounds efficiently in practice using integer linear programming (ILP). Practical results on simulated and real biological data show that the bounds can be computed for wide range of data. Moreover, the lower and upper bounds are often close, especially when the number of trees is small or reticulation level is relatively low. In fact, for many simulated datasets of this type, the lower and upper bounds often match, which means our methods can reconstruct the exact minimum reticulate networks for these datasets. We also show the RH bound clearly outperforms a simple bound.

2 DEFINITIONS AND BACKGROUND
Throughout this article, we assume trees are rooted. A phylogenetic tree is rooted and leaf-labeled by a set of species (called taxa). A leaf of a phylogenetic tree corresponds to an extant species. An internal vertex corresponds to a speciation event. In-degrees of all vertices (also called nodes), except the root, in a tree are one, while out-degrees are zero for leaves and at least two for internal nodes. A binary phylogenetic tree requires out-degrees of internal nodes to be two. A non-binary phylogenetic tree contains nodes with out-degree of three or more. Many existing phylogenetic methods assume binary phylogenetic trees, although sometimes only non-binary trees can be reconstructed in practice.

Our definition of reticulate networks is similar to that in (Huson, 2007; Huson et al., 2005; Semple, 2007) (Hallett and Lagergren, 2001; Nakhleh, 2009; Nakhleh et al., 2004). A reticulate network (sometimes simply network) is a directed acyclic graph with vertex set V and edge set E, where some nodes in V are labeled by taxa. V can be partitioned into VT (called tree nodes) and VR (called reticulation nodes). E can be partitioned into ET (called tree edges) and ER (called reticulation edges). Moreover,
No nodes with total (in and out) degree of two is allowed. Except the root, each node must have at least one incoming edge.

VR contains nodes whose in‚àídegrees are two or more. VT contains nodes whose in-degrees are one.

ER contains edges that go into some reticulation nodes. ET contains edges that go into some tree nodes.

A node is labeled by some taxon iff its out-degree is zero. This helps to ensure labeled nodes correspond to extant species and remove some redundancy in the network.




In addition, we have one more restriction:
R1 For a reticulate network ùí©, when only one of the incoming edges of each reticulation node is kept and the rest are deleted, we always derive a tree T‚Ä≤.




We first consider the derived tree T‚Ä≤ (that is embedded in ùí©) as in restriction R1. When we recursively remove non-labeled leaves and contract edges to remove degree-two nodes of T‚Ä≤ (called cleanup), we obtain a phylogenetic tree T (for the same set of species as in ùí©). Now suppose we are given a phylogenetic tree T. We say T is displayed in ùí© when we can obtain an induced tree T‚Ä≤ from ùí© by properly choosing a single edge to keep at each reticulation node so that T‚Ä≤ is topologically equivalent to T after cleanup. We denote the induced T‚Ä≤ (if exists) as Tùí©. See Figure 1 for an illustration.
Fig. 1. An illustration of a reticulate network with three reticulation events for three trees. Each tree is displayed in the network: the tree can be obtained by keeping one incoming edge at each reticulation node.



Note restriction R1 implies the network is acyclic. Biologically, reticulate networks often forbid cycles. This is because many reticulation events need to be properly time-ordered. Thus, we focus on acyclic reticulate networks in this paper. That is, when we refer to a reticulate network, we mean an acyclic reticulate network (unless otherwise stated).

There are subtle issues related to networks with nodes whose out-degrees are more than two (called non-binary nodes). See the Supplementary Materials for more discussion. Note that we do not require that in-degrees of reticulation nodes are precisely two as what was imposed in (Huson et al., 2005). We also assume the root of each input tree Ti is attached to an outgroup species o. The root of a reticulate network for these trees is also attached to o.

We define the reticulation number of a reticulation node as its in-degree minus one. For a reticulate network ùí©, we define the reticulation number (denoted as Rùí©) as the summation of the reticulation number of each reticulation node in the network. Sometimes Rùí© is also called the number of reticulation events in ùí©. For the reticulate network in Figure 1, the reticulation node 2 has three entering edges, and the other reticulation node 1 has two entering edges. Thus, Rùí©=(3‚àí1)+(2‚àí1)=3. Our definition of reticulation number is similar to that of the hybridization number in (Bordewich et al., 2007; Semple, 2007).

Suppose we are given a set of K gene trees T1, T2, ‚Ä¶, TK (for the same set of species). The minimum reticulate network ùí©min for T1, T2,‚Ä¶, TK is a reticulate network ùí© that displays each Ti and Rùí© is minimized among all possible ùí©. We call Rùí©min the reticulation number of T1,‚Ä¶, TK, which is denoted as R(T1, T2,‚Ä¶, TK). For the special case of K=2, we call DTi,Tj=R(Ti, Tj) the reticulation distance between two trees Ti and Tj. Now we formulate the central problem in this article.

The general minimum reticulate network (GMRN) problem: Given a set of phylogenetic trees T={T1,‚Ä¶, TK}, reconstruct the minimum reticulate network ùí©min for T1, T2,‚Ä¶, TK. This formulation is based on parsimony, and may be justified when reticulation is relatively rare in the evolutionary history.

One should note that the GMRN problem can be further specified by the type of input trees. There are two types of input phylogenetic trees: binary or non-binary. For a non-binary tree T, we say T is displayed in ùí© if some refinement of T (i.e. splitting the non-binary nodes in T in some way to make T binary) is displayed in ùí©. When input trees are binary, network reconstruction may be easier. For simplicity, in this following, the input trees are assumed to be binary, unless otherwise stated. We remark that some of our results are applicable to non-binary input trees: the RH bound in Section 3 clearly works for non-binary trees too, and the high-level approach of the SIT bound may also be applicable to non-binary trees.

Previous work on the GMRN problem: There is an exact method for the K=2 case of the minimum reticulate network problem (Bordewich et al., 2007), although this special case is known to be NP-complete (Bordewich and Semple, 2007). It is useful to note that when we allow cycles in the network, the minimum reticulate network problem is equivalent to the rooted subtree prune and regraft (rSPR) distance problem. The rSPR distance problem, another NP-complete problem (Bordewich and Semple, 2004; Hein et al., 1996), is well known to be closely related to reticulate evolution. Previously, we showed that the rSPR distance can often be practically computed for many moderately sized trees (Wu, 2009). We give more background to the rSPR distance problem in the Supplementary Material. It was shown in (Baroni et al., 2005) that the reticulation number (called hybridization number in (Baroni et al., 2005)) for trees T1 and T2 is closely related to the rSPR distance between T1 and T2, although the two values are not always equal. The main difference between the rSPR distance and the reticulation number is that the latter forbids cycles and thus can be more realistic biologically. Recently, we have extended our previous approach in (Wu, 2009) to allow computing the pairwise reticulation distance between two rooted binary trees (Wu and Wang, 2010). Although the worst case running time of the practical methods in (Bordewich et al., 2007; Wu, 2009; Wu and Wang, 2010) are exponential, these methods may work reasonably well in practice. As shown in (Bordewich et al., 2007; Wu, 2009; Wu and Wang, 2010), exact reticulation number (with or without cycles) can be computed for two quite different trees with 20 or more leaves. Thus, although intractable theoretically, the two-tree minimum reticulate network problem can be solved in practice if the size of two trees is moderate or the two trees are not very different topologically.

It becomes more computationally challenging when there are three or more gene trees. There is currently no known practical methods for either computing the reticulation number R(T1,‚Ä¶, TK) or reconstructing ùí©min for trees T1,‚Ä¶, TK when K ‚â• 3. Often approximation is made. A common approach is to impose structural constraints to limit the complexity of the network (Gusfield, 2005; Huson and Klopper, 2007; Huson et al., 2009; Nakhleh et al., 2005). Although these approaches are theoretically interesting and have been shown to work for some biological data, it is still very desirable to explore the reconstruction of reticulated networks displaying multiple complete gene trees without additional structural constraints.

3 A LOWER BOUND
We now focus on developing a lower bound on R(T1,‚Ä¶, TK). The lower bound helps to better quantify the range of R(T1,‚Ä¶, TK).

Recall that several exact methods (Bordewich et al., 2007; Wu and Wang, 2010) exist for computing the pairwise reticulation distance DTi,Tj for two trees Ti, Tj, which are practical for many pairs of trees of moderate sizes. Now suppose that we compute DTi,Tj for each pair of trees Ti and Tj, using the methods (Bordewich et al., 2007; Wu and Wang, 2010). We store these pairwise distances in a matrix D, where D[i, j]=DTi,Tj2. Admittingly, computing D[i, j] for all Ti and Tj can be slow when K and/or the size of trees are large (unless Ti and Tj are very similar). One should note that the GMRN problem is much more complex, and thus, calculation of D[i, j] is justifiable computationally. This leads to the following question: can we use the pairwise reticulation distances D to estimate R(T1,‚Ä¶, TK) when K ‚â• 3?

Clearly, the largest value D[i0, j0] in D is necessarily a lower bound of R(T1,‚Ä¶, TK) when K ‚â• 3: a reticulate network displaying all trees certainly also displays trees Ti0 and Tj0 and thus is a reticulate network for Ti0 and Tj0. We now show a stronger lower bound (called RH bound) based on D values.

Here is the high-level idea. The pairwise distance DTi,Tj specifies how similar trees Ti and Tj are: the larger DTi,Tj is, the more different Ti and Tj are. Recall that if tree Ti is displayed in a network ùí©, we should be able to derive Ti by keeping only one incoming edge at each reticulation node and performing cleanup. The choice (called display choice for Ti) of keeping which incoming edge at each reticulation node for a tree Ti may not be unique. However, clearly if one makes the same display choices for Ti and Tj when displaying Ti and Tj in ùí©, then Ti and Tj will be identical. More generally, the more similar the display choices for trees Ti and Tj, the closer Ti and Tj will be. Thus, to allow an ùí© for trees with pairwise distances D[i, j]=DTi,Tj, we need to make display choices for the trees different enough: if the display choices for Ti and Tj are too similar, it will lead to contradiction when D[i, j] suggests Ti and Tj are more different. In the following, a rigorous analysis based on this idea allows us to decide whether an ùí© with a specific number (say r) of reticulation events is feasible.

To fix ideas, we first consider the situation where each reticulation node in ùí© has in-degree of two. We will remove this assumption in a moment. Suppose that ùí© has r reticulation nodes (each with two incoming edges). For each reticulation node, we arbitrarily call one incoming edge the left edge and the right edge for the other. We encode the left edge as 0 and the right edge as 1, and call these two edges 0-edge and 1-edge. Recall that to display a tree, we need to keep exactly one of these two edges. Since a tree Ti is displayed in ùí©, we create a binary vector vi[1 ‚Ä¶ r] to represent which incoming edge Ti is kept at each reticulation node Vj in ùí©. Here, vi[j] is 0 if Ti keeps the 0-edge at reticulation node Vj, and 1 if Ti keeps the 1-edge at Vj. We call vi the display vector for Ti. For example, in Figure 1, consider the reticulation node labeled as 1, and we assign the left/right edges as shown. T1 and T3 keep the left edge at this node, while T2 keeps the right edge. Thus, v1 and v3 have value 0, and v2 has value 1 at the node.

For a given Ti and a network ùí©, vi can always be constructed (at least conceptually) based on how Ti is displayed in ùí©. Note that if there are multiple choices to display Ti, we simply pick an arbitrary one and this does not affect our solution. We define Dh[vi, vj] as the Hamming distance between two display vectors vi and vj. Here, vi and vj (and thus Dh[vi, vj]) depend on ùí©. To simplify notations, we do not explicitly include ùí© in their definitions. Lemma 3.1 is crucial to our lower bound.

Lemma 3.1.
For any two trees Ti and Tj displayed in a reticulate network ùí©, Dh[vi, vj] ‚â• D[i, j].

Proof.
For contradiction, assume Dh[vi, vj]<D[i, j]. Thus Ti and Tj make different choices at less than D[i, j] reticulation nodes of ùí©. Imagine we remove from ùí© those incoming edges at reticulation nodes that are not kept by both Ti and Tj. This produces a network with less than D[i, j] reticulation nodes. This is because all reticulation nodes where vi and vj match (and thus Ti and Tj keep the same incoming edges) have only one incoming edge and are no longer reticulation nodes in the reduced network. This contradicts the fact that D[i, j] is the reticulation distance between Ti and Tj.‚ÄÉ‚ñ™

Lemma 3.1 implies that if a network ùí© with r reticulation events exists, then we should be able to find binary vectors vi (of length r) for each tree Ti, and Dh[vi, vj] ‚â• D[i, j] for any two such vectors vi and vj. On the other hand, if such vectors do not exist, we know that at least r+1 reticulation events are needed (and the value r+1 is a lower bound on R(T1,‚Ä¶, TK)). We can illustrate this formulation more intuitively using a binary hypercube. On a hypercube with r binary bits per node, we want to know whether we can pick K points v1 ‚Ä¶ vK that are far apart enough such that the Hamming distance between vi and vj is at least D[i, j] for each i and j. One should note this is not always feasible due to the limited size of the hypercube. Formally,

The binary hypercube point placement problem: Can we choose K nodes v1,‚Ä¶, vK from a r-dimensional binary hypercube so that Dh[vi, vj] ‚â• D[i, j] for each pair of vi and vj?

A lower bound on R(T1,‚Ä¶, TK) based on the Hypercube Point Placement problem is to find (possibly in a binary search style) the smallest integer r such that the hypercube point placement problem has a solution. Such r is necessarily a lower bound on R(T1,‚Ä¶, TK). We call this lower bound reticulation on hypercube bound (or RH bound).

We do not know a polynomial-time algorithm for the binary hypercube point placement problem with more than three trees. When K=3, however, the RH bound has a simple analytical form (see Section 3.2). To develop a practical method for the general case, we use integer linear programming (ILP) to solve this problem. We create a binary variable Vi,k to represent the coordinates for point vi. That is, the coordinates of vi on the hypercube are specified by Vi,1 ‚Ä¶ Vi,r. Without loss of generality, we set V1,k=0 for all 1‚â§k‚â§r. We create a binary variable Mi,j,k for each vi, vj and position k (1‚â§k‚â§r) to indicate whether two vectors vi and vj match at position k. Mi,j,k=1 if Vi,k=Vj,k, and 0 otherwise. Now, we have the following formulation.
Optimization goal: none (since this is a feasibility problem)

Subject to





Mi,j,k+Vi,k+Vj,k ‚â• 1, for each vi, vj, where i<j and 1‚â§k‚â§r.

Mi,j,k ‚àí Vi,k ‚àí Vj,k ‚â• ‚àí1, for each vi, vj, where i<j and 1‚â§k‚â§r.

‚àëk=1r Mi,j,k ‚â§r‚àíD[i, j], for each vi, vj, where i<j.





For each 1‚â§i‚â§K and 1‚â§k‚â§r, there is a binary variable Vi, k.

For each 1‚â§i<j‚â§K, and 1‚â§k‚â§r, there is a binary variable Mi,j,k.




Constraint 1 says if both Vi,k and Vj,k are 0, Mi,j,k is 1 (i.e. matched). Similarly, constraint 2 says if both Vi,k and Vj,k are 1, Mi,j,k is 1 (i.e. matched). Constraint 3 imposes the pairwise Hamming distance requirement. Our experience shows that the ILP is practical to solve for all datasets we simulated (see Section 5).

3.1 Networks with in-degree of three or more
We now resolve the remaining issue where some reticulation nodes have in-degree of three or more. In this section, we call a reticulation node ‚Äòrefined‚Äô if its in-degree is two, and ‚Äòunrefined‚Äô if its in-degree is at least three.

Here, we can no longer represent a reticulation node as binary value, as done previously. So we extend our definitions of display vectors vi to allow vi to be non-binary. That is, if there are d incoming edges at a reticulation node, we allow vi to be from 0 to d‚àí1, where the value indicates which one of the d branches Ti is kept at this node. The incoming edges are numbered starting from zero on the left and to the right with increment of one. We still let Dh[vi, vj] be the Hamming distance between vectors vi and vj. In this general case, Lemma 3.1 still holds for non-binary vectors vi and vj. To see this, we prune any incoming edge at reticulation nodes if it is not chosen by Ti and Tj. Then each remaining reticulation node has only two incoming edges (since we only have two trees). Thus, there are Dh[vi, vj] reticulation events in this reduced network, and the rest of proof for Lemma 3.1 follows.

We now show that it is not necessary to consider unrefined reticulation nodes in the sense that if a network ùí© with unrefined reticulation nodes satisfies pairwise distances D, then there exists another network ùí©‚Ä≤ that has only refined reticulation nodes and gives the binary vectors vi satisfying the pairwise distance constraints of D. That is, if we can not find a network with only refined reticulation nodes, we also can not find a network with unrefined reticulation nodes and the same reticulation number.

To see this property, we consider a network ùí© with one reticulation node q with d ‚â• 3 incoming edges. Then we transform ùí© to ùí©‚Ä≤ by replacing q with q1,‚Ä¶, qd‚àí1, where each qi is a reticulation node with in-degree of two. Note that we do not have to ensure ùí© and ùí©‚Ä≤ are equivalent: we only need to show ùí©‚Ä≤ gives a solution to the Binary Hypercube Point Placement problem. Clearly, ùí© and ùí©‚Ä≤ have the same reticulation number (although vectors for ùí©‚Ä≤ are longer). Now, suppose tree Ti keeps edge j at q (where 0‚â§j‚â§d‚àí1), we then keep edge 1 at qj in ùí©‚Ä≤ if j ‚â• 1 (and 0 if j=0), and keep edge 0 for all other qj‚Ä≤ (where j‚Ä≤‚â†j). In other words, we create a mapping of the display vectors vi from ùí© to ùí©‚Ä≤ for each Ti. Note that such mapping ensures that if two trees keep the same edge at q, they will keep the same edges at q1,‚Ä¶, qd‚àí1 in ùí©‚Ä≤; otherwise, they will keep at least one different incoming edge at q1,‚Ä¶, qd‚àí1 in ùí©‚Ä≤. In either case, if the pairwise distance constraints are satisfied in ùí©, they are also satisfied in ùí©‚Ä≤. So, if we can not find display vectors ùí©‚Ä≤ for networks with refined reticulation nodes only, we also can not find display vectors for networks allowing unrefined reticulation nodes. In other words, the RH bound holds for networks with unrefined nodes.

Remark. The RH lower bound is still applicable when the input trees are non-binary, as long as the pairwise reticulation distances are obtained for the non-binary trees. These are easy to verify and we omit the details due to the lack of space.

Remark. A commonly used concept in reticulate networks is the so-called maximum agreement forest (MAF). A brief description on MAF is given in the Supplementary Material. Also see e.g. in (Semple, 2007) for more details. It is easy to see that the size of a MAF of multiple trees is a lower bound on R(T1,‚Ä¶, TK). However, experience show that the RH bound is often higher than the MAF bound (see Section 5).

3.2 Special case of three trees
The special case of K=3 allows us to study the RH bound in an analytical way. We let d1, d2 and d3 be the pairwise reticulation distances of the three trees, where d1 ‚â• d2 ‚â• d3. Proposition 3.2 shows the RH bound for three trees in an analytical form.

Proposition 3.2.
The RH lower bound for three trees T1, T2 and T3 is equal to  if d2+d3>d1, and equal to d1 if d2+d3‚â§d1.

Proof.
We first consider the case d2+d3>d1. Clearly, the RH bound is at least d1, which is the minimum size of the hypercube. Now we investigate whether there exists a reticulate network with d1+e reticulation nodes for these three trees. Without loss of generality, let T1 be the input tree where d1=DT1,T2 and d2=DT1,T3, and the display vector v1 (for T1) is fixed to be all-0. Then, the display vector v2 for T2 must have at least d1 positions with value 1 (and thus v2 has no more than e positions with value 0). Similarly, the display vector v3 must have at least d2 positions with value 1 (and thus v3 has no more than d1+e‚àíd2 positions with value 0). Note that Dh[v2, v3] ‚â• d3. We claim that Dh[v2, v3]‚â§d1+2e‚àíd2. This is because the Hamming distance between v2 and v3 counts the positions where v2 has value 0 and v3 has value 1 (or vice versa). Since the number of 0s in v2 is no more than e, there are at most e positions where v2 has 0 and v3 has 1. Similarly, there are at most d1+e‚àíd2 positions where v2 has 1 and v3 has 0. Thus, Dh[v2, v3]‚â§e+d1+e‚àíd2=d1+2e ‚àí d2. Also note that we can always construct v2 and v3 so that Dh[v2, v3]=d1+2e‚àíd2. See Figure 2 for an illustration.
Fig. 2. Vectors v1, v2 and v3 (listed from top to bottom) that maximize the Hamming distance between v2 and v3. v1 is all-0, while the suffix of v2 and prefix of v3 are zeros.



Therefore, if d1+2e‚àíd2 < d3, we can not find three vectors v1, v2 and v3 satisfying the pairwise distances D and thus R(T1, T2, T3) ‚â• d1+e+1 in this case. The largest such e is equal to  (which is non-negative since d2+d3 > d1). The RH bound is then  = .

The case when d2+d3‚â§d1 is simple. We create three vectors of d1 bits: v1 is an all-0 vector, v2 is an all-1 vector and v3 contains d2 1s. It is easy to verify these three vectors satisfy all three pairwise distance constraints.‚ÄÉ‚ñ™

In practice, it is very likely d2+d3 > d1. In this case, , where d1 is a trivial lower bound.

4 AN UPPER BOUND
We now present an upper bound on R(T1,‚Ä¶, TK). The combination of the RH lower bound and the upper bound quantifies the range of R(T1,‚Ä¶, TK). In the best scenario, if the upper bound matches the RH bound, these bounds would actually determine the exact value of R(T1,‚Ä¶, TK) (and also reconstruct ùí©min). On the high level, the upper bound performs stepwise insertion of trees into a reticulate network (and thus is called the SIT bound). The SIT bound is very accurate and also computable in practice for many datasets.

The basic idea of the SIT bound is to reconstruct a reticulate network ùí© in a step-by-step way: ‚Äòinsert‚Äô the given gene trees one by one into ùí© in some fixed order. When we say a tree T is inserted into ùí©, we mean adding reticulation edges into ùí© such that T is displayed in the updated network ùí©‚Ä≤. Note that addition of new reticulation edges increases Rùí©. Thus, every time we insert a new tree, we seek to add as few new reticulation edges as possible by reusing existing reticulation edges. At the same time, we also ensure no cycles exists in ùí©‚Ä≤. Often, it is unclear which order of inserting trees gives the best result. For now, we assume that K is relatively small so that we can enumerate all possible orders of insertion to find the best result. See Section 4.2 for ways to handle larger K. Thus, we can assume the order of tree insertion is fixed to T1, T2,‚Ä¶, TK. The general procedure of the SIT bound (for a fixed order) is as follows.
Initialize ùí© to be T1.

for i=2 to K

Insert Ti into ùí© by adding the smallest number of new reticulation edges.




Note that we only add reticulation edges in ùí© and do not delete any existing edges. Thus, any tree already displayed in ùí© is still displayed in the updated ùí©‚Ä≤ by choosing the original reticulation edges when the tree is first inserted for their display vectors in ùí©‚Ä≤. This ensures that each of the input trees is displayed in the final ùí©. Obviously, step 3 is most critical, which we will discuss next.

4.1 Inserting tree T into ùí©
We consider the ‚Äòmin-cost tree insertion problem‚Äô, where we want to update ùí© by adding the fewest reticulation edges to ùí© so that a given tree T is displayed in the updated ùí©‚Ä≤, and ùí©‚Ä≤ remains acyclic. Note that the min-cost tree insertion problem is NP-complete because it contains the two-tree minimum reticulate network problem (an NP-complete problem) as a sub-problem. That is, constructing the minimum reticulate network for trees T1 and T2 can be solved by inserting T2 into T1 with the minimum cost. In the following, we develop a practical method to solve the min-cost tree insertion problem. Each node of the reconstructed network here has one or two incoming edges (except the root), and one or two outgoing edges (except the leaves).

After inserting T (and some new reticulation edges are added), T is displayed in the updated network ùí©‚Ä≤. Suppose we remove all the new reticulation edges in ùí©‚Ä≤. The edge removals break tree T(ùí©‚Ä≤) (the tree created by keeping edges in ùí©‚Ä≤ according to a display vector of T) into a forest F(T(ùí©‚Ä≤)). Thus, the number of newly added reticulation edges is exactly the number of trees in F(T(ùí©‚Ä≤)) minus one. To minimize the number of needed new reticulation events, we need to minimize the number of trees in F(T(ùí©‚Ä≤)). A useful observation is that the problem of finding F(T(ùí©‚Ä≤)) with the fewest subtrees is closely related to the maximum agreement forest problem (see the Supplementary Material) as follows.

Imagine that we choose a tree T‚Ä≤ that is displayed in ùí© so that the display vector of T‚Ä≤ agrees with that of T for ùí©‚Ä≤ at each reticulation node of ùí©. Recall that ùí©‚Ä≤ may contain a number of new reticulation nodes that are not in ùí©. Also note T‚Ä≤ is not necessarily one of the input trees Ti. We claim that F(T(ùí©‚Ä≤)) is an agreement forest for T and T‚Ä≤. To see this, we note that the display choices made by T‚Ä≤ are identical to T except those at the new reticulation nodes (where T‚Ä≤ follows the original edge and T(N‚Ä≤) follows the new edge). So the subtrees in F(T(ùí©‚Ä≤)) must also be subtrees of T‚Ä≤. So, we have:

Lemma 4.1.
The forest induced by removing newly added reticulation edges of T(ùí©‚Ä≤) is an agreement forest between T and some tree T‚Ä≤ that is displayed in the original ùí©.

Lemma 4.1 implies that to find the best tree insertion, we can find some tree T‚Ä≤ displayed in ùí© s.t. the number of trees in the maximum agreement forest between T and T‚Ä≤ is minimized. Figure 3 shows an example of tree insertion. The dashed lines in the tree (left) divide the tree into a forest, which also appears in the existing network (middle, thick lines). Inserting the tree into the network is to add new reticulation edges (right, thick lines) into the networks so that the subtrees in the forests are properly connected to match the given tree.
Fig. 3. Inserting a tree (left) to a network (middle). After adding new reticulation edges (thick lines), the resulting network (right) displays the tree.



When the number of reticulation nodes in ùí© is small, we may simply enumerate all trees T‚Ä≤ displayed in ùí© and then find which T‚Ä≤ gives the smallest agreement forest with T. This quickly becomes infeasible as the number of reticulation nodes in ùí© grows: when there are r reticulation nodes in ùí©, there may exist 2r trees T‚Ä≤ displayed in ùí©. To develop a practical method, we develop an integer linear programming (ILP) formulation to solve the tree insertion problem in an optimal way (without explicit enumeration). The output of the ILP formulation includes the display choices of T‚Ä≤ as well as the associated agreement forest formed by cutting edges in T. See the Supplementary Material for detailed description of the formulation.

Updating ùí©: after tree T‚Ä≤ and the associated agreement forest are found, we update ùí© as follows. We add new reticulation edges in ùí© to connect subtrees of T‚Ä≤ in the found agreement forest to make T displayed in the updated network ùí©‚Ä≤. First, we determine the order of subtree connection with an approach similar to the algorithm building two-tree hybridization networks in (Semple, 2007). The subtree with the special outgroup taxon o acts as the base. Then we repeatedly pick the subtree not intersecting any already connected subtree as the next to connect. Now, for each tree connection:
Find the root r of the next subtree (in ùí©) to attach.

Find the node v in the existing network as the attaching point to accept this subtree.

Create a new reticulation node in ùí© to connect the subtree.




This operation depends on the types of r and v. Two cases are shown in Figure 4. The other cases are similar. In all the cases, only a single new reticulation edge is created to connect a subtree.
Fig. 4. Attaching a subtree in ùí©. Left: insert a reticulation edge between two tree nodes r and v. Right: insert a reticulation edge between two reticulation nodes r and v. The dashed lines are the newly added edges.



Cycles: a remaining issue is that cycles can be introduced when connecting subtrees in ùí©. There are two sources of cycles. First, the found agreement forest may induce cycles (see (Baroni et al., 2005)). Enhancing the ILP formulation to avoid cycles may significantly complicate the formulation and slow the ILP solving. A practical observation is that cycles in an agreement forest are often caused by two pairs of leaves a, b and c, d so that the a/b pair is ancestral to c/d pair in T and the c/d pair is ancestral to a/b pair in T‚Ä≤. Here, we say a pair of leaves a and b is ancestral to a pair of leaves c and d if the the MRCA of a and b is ancestral to the MRCA of c and d. MRCA stands for the most recent common ancestor, and node a is ancestral to node b in tree T if a is on the path from b to the root of T. To forbid this type of simple cycles, we enhance the ILP formulation: for such pairs a/b and c/d, we require either a and b are not in the same subtree, or c and d are not in the same subtree of the resulting forest. Although this does not guarantee to remove all cycles, we found that cycles in the agreement forest are rare after this change. This observation is also useful for the method of computing pairwise reticulation distances in (Wu and Wang, 2010).

Second, cycles can appear in other parts of the network when subtrees in the agreement forest are connected. In practice, however, we find this happens relatively rare. When this type of cycles does occur, we simply start over and try another order of tree insertion. This works well in practice: in Section 5, we build acyclic networks successfully for all (thousands of) simulated datasets.

4.2 Handling larger datasets
When the size and the number of trees grow, the running time increases. To handle larger datasets, we make several simplifications. (i) Instead of enumerating all possible orders of tree insertion, we start with an arbitrary tree. At each step, we pick a tree with the smallest reticulation distance to one of the already inserted trees. (ii) Solving the min-cost tree insertion problem optimally becomes more difficult when data grows. So instead of considering all possible T‚Ä≤ displayed in ùí© when inserting T, we randomly choose a fixed number (say 10) of trees T‚Ä≤ displayed in ùí© (in addition to all the inserted gene trees) and find the best way of inserting T based on one of the chosen T‚Ä≤. This heuristic is called the coarse mode (and the original approach is called the full mode). Our experience shows that the coarse mode works reasonably well in practice (see Section 5).

5 EXPERIMENTAL RESULTS
We have implemented a software tool called PIRN (which stands for Parsimonious Inference of Reticulate Network) to compute the RH and SIT bounds. Program PIRN is available for download from: http://www.engr.uconn.edu/Àúywu/. The tool is written in C++ and uses either CPLEX (a commercial ILP solver) or GNU GLPK ILP solver (mainly a demo of the functionalities for users without a CPLEX license). In computing the SIT bound, PIRN can run full mode (slower but can give better results) or coarse mode (faster but less accurate). We test our methods for both simulated and biological data on a 3192 MHz Intel Xeon workstation.

5.1 Simulation data
We generate simulation data using a two-stage approach: first simulate reticulate networks, and then generate a fixed number of trees displayed in the networks according to randomly generated display vectors. We simulate reticulate networks using a scheme similar to the coalescent simulation implemented in program ms (Hudson, 2002). For a given number of taxa (denoted as n), we start with n isolated lineages and simulate reticulation backwards in time. At each step, there are two possible events: (i) lineage merging, which occurs at rate 1; (ii) lineage splitting, which occurs at rate r. We choose the next event according to relative probabilities of all feasible events. Lineage merging generates speciation events, while lineage splitting generates reticulation events. To speedup the simulation, lineage splitting is disabled when the number of current lineages is no more than three. The parameter r dictates the level of reticulation in the simulated network: larger r will lead to more reticulation events in simulation.

Full mode of the SIT bound: to test the performance of the bounds, we generate data with varying number of trees K, number of taxa n and level of reticulation r. For each settings of these three parameters, we simulate 100 datasets. We report the percentage of datasets where optimal solution is found (i.e. lower bound matches upper bound) in Figure 5a. To show how close the lower and upper bounds are, we report the average gap (the difference between the upper and the lower bounds, divided by the lower bound) in Figure 5b. We also report the average lower bound in Figure 5c, which somewhat reflects how complex the simulated networks are. We also give the average running time for each setting in Figure 5d. For five larger datasets, there are a small number of test cases that are too slow to run the full mode, and are excluded. The percentage of unfinished computation is usually one or two out of 100 datasets, except the cases with n=30/r=3.0/K=5 (18% unfinished) and n=30/r=5.0/K=4 (6% unfinished). This suggests the current practical range of the full mode of the SIT bound.
Fig. 5. Performance of the RH bound and SIT bound (full mode), for 10, 20, 30, 40 and 50 taxa, number of trees K from 3 to 5, and reticulation level r at 1.0, 3,0 and 5.0. (a). The percentage of exact reticulation number found among 100 simulated datasets. (b) Average gaps (in percentage) between the SIT bound and RH bound (normalized by the RH bound), and the average RH bound is shown in (c). (d) The average running time (in seconds). The reticulation level r for left, middle and right figures is 1.0, 3.0 and 5.0, respectively. Horizontal axis is the number of taxa, and each curve in a figure is for a value of K.



As shown in Figure 5a, PIRN performs very well when the number of trees K=3 or reticulation level r is small: optimal solution can be found for at least 80% of simulated datasets when r=1.0 and K=5. Even with higher reticulation level (r=3.0) and larger number of taxa (say 50), still about 60% of datasets can be solved exactly when K=3. As expected, as the number of taxa, reticulation level and the number of trees grow, fewer datasets can be solved to exact, and correspondingly, Figure 5b shows gaps between the RH and SIT bounds increase. Figure 5c shows the complexity of networks increases too. Nevertheless, the gaps are still relatively small in these cases. For the more difficult settings simulated (i.e. 30 taxa, high reticulation level and five trees as input), the gap is about 25%. Running time depends on the complexity of the networks. Figure 5d shows that PIRN is practical for data of medium size.

Coarse mode of the SIT bound: we also test the coarse mode of our methods for larger data, as described in Section 4.2. The results are shown in Figure 6. The figure on the left shows the effects (on accuracy and running time) of increasing the number of taxa n. The figure on the right shows the effects of having more trees (i.e. increasing K from three to nine) for 10 taxa and reticulation level 5.0. There is clear trade-off between the accuracy of solutions and efficiency. The coarse mode under-performs in terms of the quality of solutions, but is more scalable, especially when K increases. When the number of taxa increases, the coarse mode is likely to run faster than the full mode, but the difference is less significant.
Fig. 6. Comparing the coarse (C) mode and the full (F) mode of the SIT bound. Left: fix r=3.0 and K=4, while varying n. Right: fix r=5.0 and n=10 and vary K. Both percentages of optimal solutions found and running time (in minutes for the left figure and seconds for the right one) are shown.



GLPK: the CPLEX solver is used in the simulation. The GLPK version in general is less robust and can handle smaller data than the CPLEX version. Our experience shows that the GLPK solver can often solve for five trees with 30 taxa when reticulation level is low and fewer number of taxa when reticulation level is higher.

The RH bound: we now compare the performance of the RH bound with the MAF bound. We note that the MAF bound is not easy to compute: finding the MAF of only two trees is known to be NP-hard. When data is small, the MAF bound can be computed (e.g. using ILP similar to that in (Wu, 2009)). In Table 1, we compare the RH bound and the MAF bound for 100 datasets. Each data has 10 or 20 taxa and contain three to seven correlated trees. The trees are selected from the local trees for recombining sequences generated by a coalescent simulator, program ms (Hudson, 2002).
Table 1. Compare the RH and MAF bounds for K trees

		K=3	K=4	K=5	K=6	K=7	
n=10	RH > MAF	46	56	61	58	72	
	RH = MAF	54	44	38	41	27	
	RH < MAF	0	0	1	1	1	
	100 (RH ‚àí MAF/MAF)	16.5	18.4	17.2	18.0	20.9	
	
n=20	RH > MAF	65	66	68	70	-	
	RH = MAF	34	34	30	30	-	
	RH < MAF	1	0	2	0	-	
	100 (RH ‚àí MAF/MAF)	12.6	11.9	12.1	12.8	-	
RH > MAF: number of datasets where the RH bound is larger than the MAF bound among 100 datasets. The average gaps (in percentage) between the RH and MAF bounds are also shown.




Table 1 shows that the RH bound outperforms the MAF bound in a majority of the simulated datasets and only very rarely the RH bound is lower than the MAF bound. In general, as the number of trees increases, the RH bound tends to outperform the MAF bound in both accuracy and running time. For example, for a dataset with 20 sequences and six input trees, CPLEX runs for over 11 h without reporting a solution (it found a solution of 11, but did not validate its optimality). In contrast, it only takes less than 1 minute to compute the RH bound of value 12 (higher than the MAF result).

5.2 Biological data
To evaluate how well our bounds work for real biological data, we test our methods on a Poaceae dataset. The dataset was originally from the Grass Phylogeny Working Group (Grass Phylogeny Working Group, 2001). The dataset contains sequences for six loci: internal transcribed spacer of ribosomal DNA (ITS); NADH dehydrogenase, subunit F (ndhF); phytochrome B (phyB); ribulose 1,5-biphosphate carboxylase/oxygenase, large subunit (rbcL); RNA polymerase II, subunit Œ≤‚Ä≤‚Ä≤ (rpoC2); and granule bound starch synthase I (waxy). The Poaceae dataset was previously analyzed and rooted binary trees were inferred for these loci (Schmidt, 2003). Pairwise comparison were performed in (Bordewich et al., 2007; Wu and Wang, 2010). Here, we provide in Table 2 our results on estimating the reticulation number using multiple (three to five) trees. Only shared taxa of a set of trees are kept. Thus, the pairwise distances reported here are different from those in (Bordewich et al., 2007; Wu, 2009). As shown in Table 2, PIRN finds optimal solutions for both datasets with three trees, and computes lower and upper bounds that are close for the dataset with five trees. Figure 7 shows the reconstructed reticulate network for these five trees. See Supplementary Material for a graphical display of the five grass trees. The network contains 13 reticulation events, and the lower bound is 11. Although the network may not be optimal, the gap between the lower and upper bounds is relatively small.
Fig. 7. A reticulate network found by program PIRN for five trees of a grass dataset. Red (shaded) balls represent reticulation nodes.


Table 2. Results for the grass data

Trees	n	D	RH	SIT	Time	
rpoC2, waxy, ITS	10	1, 6, 6	7	7	1 s	
ndhF, phyB, rbcL	21	4, 5, 6	8	8	1 s	
ndhF, phyB, rbcL,rpoC2, ITS	14		11	13	26 min 38 s	
Both RH and SIT bounds are shown, as well as the running time . n: the number of taxa. D: pairwise distances.



Remark: the following lists several aspects on the performance of PIRN. (i) Simulation shows that PIRN is often able to find the exact reticulation number when K or r is small, even when the number of taxa increases to medium size (say 50). Moreover, PIRN can compute the RH and SIT bounds for a wide range of data, despite the fact that we do not currently have polynomial-time algorithms for computing the bounds. We achieve this with the help of integer linear programming. (ii) Computing the RH bound is often much faster and more scalable than the SIT bound. Experience shows that the ILP formulation for computing the RH bound is often very fast to solve and computing the pairwise reticulation distances usually takes less time than finding a good upper bound for all trees. The RH bound computation will also benefit from future improvements in computing the pairwise reticulate distances. The simulation results in this section are based on an earlier version of the method in (Wu and Wang, 2010) and speedup may be possible with the latest methods. (iii) The number of trees K and the similarity of tree topologies have impact on PIRN's optimality and running time. Using more powerful ILP solver (e.g. CPLEX) and/or more powerful machines may also help for more difficult cases. (iv) Finally, our general approaches can be applied to larger data by using efficient computable lower bounds of pairwise rSPR distances in computing the RH bound, and faster but less accurate heuristics to insert trees into a network.

Supplementary Material
[Supplementary Data]
 1Other terms have been used in literature, such as phylogenetic networks and hybridization networks

2It is not known whether pairwise reticulation distance satisfies the triangle inequality, although it clearly does when cycles are allowed. In practice, pairwise reticulation distances often obey the triangle inequality: we have not found a counter-example from many simulation datasets.

ACKNOWLEDGEMENT
I thank Simone Linz for useful discussions and for sharing the grass tree dataset.

Funding: U.S. National Science Foundation (IIS-0803440) and the Research Foundation of University of Connecticut.

Conflict of Interest: none declared.
==== Refs
REFERENCES
Baroni M    Bounding the number of hybridisation events for a consistent evolutionary history J. Math. Biol. 2005 51 171 182 15868201 
Baroni M    A framework for representing reticulate evolution Ann. Comb. 2004 8 391 408 
Bordewich M    A reduction algorithm for computing the hybridization number of two trees Evol. Bioinform. 2007 3 86 98 
Bordewich M  Semple C   On the computational complexity of the rooted subtree prune and regraft distance Ann. Comb. 2004 8 409 423 
Bordewich M  Semple C   Computing the minimum number of hybridization events for a consistent evolutionary history Dis. Appl. Math. 2007 155 914 928 
Grass Phylogeny Working Group Phylogeny and subfamilial classification of the grasses (poaceae) Ann. Mo. Bot. Gard. 2001 88 373 457 
Gusfield D   Optimal, efficient reconstruction of Root-Unknown phylogenetic networks with constrained and structured recombination J. Comput. Syst, Sci. 2005 70 381 398 
Hallett M  Lagergren J   Efficient algorithms for lateral gene transfer problems Proceedings of Fifth Annual Conference on Research in Computational Molecular Biology (RECOMB 2001) 2001 New York, NY, USA ACM 149 156 
Hein J    On the complexity of comparing evolutionary trees Dis. Appl. Math. 1996 71 153 169 
Hudson R   Generating samples under the Wright-Fisher neutral model of genetic variation Bioinformatics 2002 18 337 338 11847089 
Huson D   Gascuel O  Steel M   Split networks and reticulate networks Reconstructing Evolution: New Mathematical and Computational Advances. 2007 Oxford, UK Oxford University Press 247 276 
Huson D  Bryant D   Application of phylogenetic networks in evolutionary studies Mol. Biol. Evol. 2006 23 254 267 16221896 
Huson D  Klopper T   Speed T  Huang H   Beyond galled trees - decomposition and computation of galled networks Proceeding of RECOMB 2007: The 11th Annual International Conference Research in Computational Molecular Biology 2007 4453 Berlin / Heidelberg Springer 211 225 of LNBI  
Huson D    Reconstruction of reticulate networks from gene trees Proceeding of RECOMB 2005: The 9th Annual International Conference Research in Computational Molecular Biology 2005 3500 Berlin / Heidelberg Springer 233 249 of LNBI  
Huson D    Computing galled networks from real data Bioinformatics 2009 25 i85 i93 19478021 
Linz S  Semple C   Hybridization in nonbinary trees IEEE/ACM Trans. Comput. Biol. Bioinform. 2009 6 30 45 19179697 
Nakhleh L   Heath L  Ramakrishnan N   Evolutionary phylogenetic networks: models and issues The Problem Solving Handbook for Computational Biology and Bioinformatics. 2009 New York, USA Springer, New York Inc 
Nakhleh L    Reconstructing reticulate evolution in species - theory and practice Proceeding of 8th Annual International Conference on Computational Molecular Biology 2004 Berlin / Heidelberg Springer 337 346 
Nakhleh L    Reconstructing reticulate evolution in species - theory and practice J. Comp. Biol. 2005 12 796 811 
Schmidt H   Phylogenetic trees from large datasets PhD Thesis 2003 Dusseldorf Heinrich-Heine-Universitat 
Semple C   Gascuel O  Steel M   Hybridization networks Reconstructing Evolution: New Mathematical and Computational Advances. 2007 Oxford Oxford University Press 277 309 
van Iersel L    Vingron M  Wong L   Constructing level-2 phylogenetic networks from triplets Proceeding of RECOMB 2008: The 12th Annual International Conference Research in Computational Molecular Biology 2008 4955 Berlin / Heidelberg Springer 450 462 of LNBI  
Wu Y   A practical method for exact computation of subtree prune and regraft distance Bioinformatics 2009 25 190 196 19019848 
Wu Y  Wang J   Borodovsky M    Fast Computation of the exact hybridization number of two phylogenetic trees Proceeding of ISBRA 2010: The 6th International Symposium on Bioinformatics Research and Applications 2010 6053 Berlin / Heidelberg Springer 203 214 of Lecture Notes in Bioinformatics
